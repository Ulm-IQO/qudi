# -*- coding: utf-8 -*-

"""
A module for reading a joystick controller via joystick itnerface.

Qudi is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Qudi is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Qudi. If not, see <http://www.gnu.org/licenses/>.

Copyright (c) the Qudi Developers. See the COPYRIGHT.txt file at the
top-level directory of this distribution and at <https://github.com/Ulm-IQO/qudi/>
"""

from core.module import Connector
from core.configoption import ConfigOption
from logic.generic_logic import GenericLogic
from qtpy import QtCore
import numpy as np


class JoystickLogic(GenericLogic):
    """ This logic module get data from a hardware controller and emit signals based on input

    This module should be between the hardware and other logic modules

    Example configuration :
        joystick_logic:
        module.Class: 'joystick_logic.JoystickLogic'
        max_fps: 100
        connect:
            hardware: dummy_joystick
    """
    _modclass = 'joysticklogic'
    _modtype = 'logic'

    # declare connectors
    hardware = Connector(interface='JoystickInterface')

    _max_fps = ConfigOption('max_fps', 100)
    _axis_threshold = ConfigOption('axis_threshold', 0.05)  # a smaller axis position will not trigger an event
    _compensate_error = ConfigOption('compensate_error', True)  # activate if the threshold is not enough.
    _fps = _max_fps

    enabled = False

    _last_state = None
    _module_list_listening = None

    _errors = {'left_vertical': 0, 'left_horizontal': 0, 'right_vertical': 0, 'right_horizontal': 0}
    _error_count = 1

    _button_list = ['left_up', 'left_down', 'left_left', 'left_right', 'left_joystick',
               'right_up', 'right_down', 'right_left', 'right_right', 'right_joystick',
               'middle_left', 'middle_right', 'left_shoulder', 'right_shoulder']

    _axis_list = ['left_vertical', 'left_horizontal', 'right_vertical', 'right_horizontal',
                  'left_trigger', 'right_trigger']

    def on_activate(self):
        """ Initialisation performed during activation of the module.
        """
        self._module_list_listening = {}
        self.timer = QtCore.QTimer()
        self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.loop)
        self.start_loop()

    def on_deactivate(self):
        """ Perform required deactivation.
        """
        self.stop_loop()
        self._module_list_listening = {}
        pass

    def fps(self, value=None):
        """ Set ou get the frequency at which the hardware is read
        """
        if value is not None:
            self._fps = value
        return self._fps

    def stop_loop(self):
        """ Stop the data recording loop.
        """
        self.enabled = False
        self.timer.stop()

    def start_loop(self):
        """ Stop the data recording loop.
        """
        self.enabled = True
        self._last_state = self.hardware().get_state()
        self.timer.start(1000 * 1 / self._fps)

    def register(self, module_id, callback, trigger_keys={}):
        """ Function called by external modules to register to notifications based on a trigger configuration

         @param module_id: A identifier for the link, that can be used to unregister
         @param callback: A function called to receive a notification. Get the state object generated by this module
         @param trigger_keys: A dictionary of keys values (True or False) that has to be in the specific state

         For example {'right_up' : True, 'right_left' : False} means that the listening module only wants notification
         if 'right_up' is pushed and 'right_left' is not pushed.
         This means some complex combination can be created to address a large number of modules.

         """
        if module_id in self._module_list_listening:
            self.log.error('Module {} is already registered to joystick logic'.format(module_id))
        else:
            self._module_list_listening[module_id] = {'callback': callback, 'trigger_keys': trigger_keys}

    def unregister(self, module_id):
        """ Function called by external modules to unregister to notifications """
        if module_id in self._module_list_listening:
            self._module_list_listening.pop(module_id, None)

    def loop(self):
        """ Loop function of the module. Get state  from hardware and push notifications to module listening
        """
        old_state = self._last_state
        state = self.hardware().get_state()
        self._last_state = state

        if not self.enabled:
            return

        if self._compensate_error:
            state = self._update_error_statistics(state)

        # First this look at button pressed/released and creates an easily accessible list
        state['pressed_buttons'] = []
        state['released_buttons'] = []
        for button in self._button_list:
            if state['buttons'][button] != old_state['buttons'][button]:
                if state['buttons'][button]:
                    state['pressed_buttons'].append(button)
                else:
                    state['released_buttons'].append(button)

        # Generate a trigger value with trigger value that can be directly accessed
        state['axis']['trigger'] = state['axis']['right_trigger'] - state['axis']['left_trigger']

        # Secondly, this look at the modules who are listening and tell the one who have to be triggered
        for module_key in self._module_list_listening:
            module = self._module_list_listening[module_key]

            module_triggered = True
            for trigger_key in module['trigger_keys']:
                if state['buttons'][trigger_key] != module['trigger_keys'][trigger_key]:
                    module_triggered = False

            if module_triggered:
                module['callback'](state)

        self.timer.start(1000 * 1 / self._fps)
        # time.sleep(1/self._fps)
        # self.loop()

    def get_last_state(self):
        """ Return last acquired state
        """
        return self._last_state

    def _update_error_statistics(self, state):
        """ Function  called internally when a new state is received to record the default value of the axis

         The horizontal and vertical axis have a permanent error.
         One way to reduce this effect is to use a threshold but this often is not enough because of a relativerly
         large systematic error. This idea of the feature is to compute the mean value of the controller axis to
         use this position as the zero.
         """
        axis = state['axis']
        keys = ['left_vertical', 'left_horizontal', 'right_vertical', 'right_horizontal']
        # if all the axis are zero, eithere the controller is perfect and this feature is not needed
        # or the controller must be unplugged so we should not count it in the statistic
        if axis['left_vertical'] == 0 and \
                axis['left_horizontal'] == 0 and \
                axis['right_vertical'] == 0 and \
                axis['right_horizontal'] == 0:
            return state

        for key in keys:
            self._errors[key] = self._errors[key]*((self._error_count-1)/self._error_count) + \
                                axis[key] / self._error_count
        self._error_count += 1

        for key in keys:
            delta = axis[key] - self._errors[key]
            if np.abs(delta) < self._axis_threshold:
                delta = 0
            axis[key] = delta

        return state
